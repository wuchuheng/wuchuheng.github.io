---
title: 03 React Hook的应用
tags:
- React
- Hook
date: 2021-11-19 3:05
---

## 1 Hook是什么？为什么要用它?
`hook`本质是个有点不一样的函数,不一样在于返回的值，如常用的`useState`,用于保存状态，那么它是怎么保存其状态的。我们知道一个组件函数被调用（渲染）
里面的引用函数就一定也会被调用了，之所以`useState`能保存状态是因为它能返回跟上次组件函数一样的结果，所以它是稳定的，也就是能保存组件的了状态.  
这样一来，函数组件不就跟类组件一样有状态了吗。而这只是`hook`中的一个.   <br />
&emsp; 好，回到标题的问题：`Hook`是什么？`Hook`本质是个函数，但会根据函数组件的情况，不同的`hook`有不同的实现功能。   <br />
&emsp; 那为什么要用它？相较类组件，函数组件简单轻量，好拆分，但函数组件就是函数，没有类组件的对应的状态和生命周期功能，而这些功能或多或少可能通过
`Hook`来弥补实现出来,这就是`Hook`的意义。

## 2 `useCallback` 和 `userMemo`的作用
`userCallback` 和 `userCallback`的作用是什么? `React`有一个过滤调用(渲染)的情况,组件的更新本质上就是把该函数重新调用一遍，但往后的子组件,
可能不需要调用了，就是没必要了。而组件的调用(渲染)触发条件是`state`或`props`发生变动才重新调用（渲染）自身。说白了，一但组件内有一丁点的关于`props`
或`state`或其它`hook`的变化都会引发组件全部重新再运行一次，也直接波及到全部子组件的更新。这是是函数组件更新的方式，避免不了，但可以避免一些代码块
就重复调用和子组件被动调用的渲染的情况。而组件内的代码块避免再次被调用则可以用`userCallback`来实现，而子组件则可以用`useMemo`的函数包裹子组件后，
来避免无意义渲染调用。

### 2.1 `useCallback`示例
`useCallback`的接收2个参数，一个是不变的回调函数，一个是依赖的`state`，依赖变了，函数才会重新刷新一个新的版本，如果没有则，默认不变。

``` typescript jsx
import React, {useCallback, useState} from "react";

const UseCallbackDemo = (): React.ReactElement => {
    const [count, setCount] = useState<number>(0)

    const callback = useCallback(() => {
        console.log("callback的内部访问到的count值: " + count)
        // todo some thing ...
    }, [])

    return (
        <>
            <p>count: {count}</p>
            <button onClick={() => setCount(() => count + 1) }>修改count</button>
            <button onClick={callback}>在useCallback内部打印count</button>
        </>
    )
}

export default UseCallbackDemo
```
后面不管理怎么修改`count`，而对于`callback`来说,`count`就是0，因为`callback`是不变的，哪怕由于外面的`count`引发组件多次刷新，可由于`callback`
并没有更新，而`callback`内部一开始访问到的`count`也就是组件第一次初始化时的参数就是0. 所以它就只能在控制台中打印出"callback的内部访问到的count值: 0"这
的结果。

(... 睡觉了，后面再说)



## 参考资料
[useCallback()、useMemo() 解决了什么问题？](https://www.jianshu.com/p/014ee0ebe959)
[React useCallback的实际应用 为什么要用这个函数？ ](https://blog.csdn.net/weixin_39107093/article/details/119514549)

)

